================================================================================
D7078E CLOUD SECURITY MINI PROJECT - COMPLETE TASK WALKTHROUGH
================================================================================

This document walks you through EVERY task step-by-step with clear guidance
on what to do, what to look for, and where to take screenshots.

================================================================================
TASK 1: PREPARE A WEB APP AMI
================================================================================

WHAT THIS TASK DOES:
  You will create a web server with a Python app that has:
  - A homepage (/)
  - A metrics endpoint (/metrics)
  - A CPU-intensive endpoint (/burn)
  
Then you'll create an AMI (machine image) from this instance so you can
launch multiple copies of it later.

STEPS TO COMPLETE:

Step 1.1: Launch EC2 Instance
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Instances â†’ Launch Instances
â”œâ”€ Name: "web-server-base"
â”œâ”€ AMI: Ubuntu 22.04 LTS
â”œâ”€ Instance Type: t2.micro
â”œâ”€ Key Pair: Your key
â”œâ”€ Network: Default VPC
â”œâ”€ Security Group: Create new "web-server-sg"
â”‚  â”œâ”€ Allow SSH (22) from your IP
â”‚  â”œâ”€ Allow HTTP (80) from 0.0.0.0/0
â”‚  â””â”€ Allow HTTPS (443) from 0.0.0.0/0
â”œâ”€ Storage: 8 GB
â””â”€ Click "Launch"

â±ï¸  Wait: 2-3 minutes for instance to reach "Running" state
âœ“ Success: Instance shows "Running" with green status checks

ğŸ“¸ Screenshot 1: EC2 instance running (see SCREENSHOT_GUIDE.txt for details)

Step 1.2: Connect to Instance via SSH
â”œâ”€ Open Terminal/PowerShell
â”œâ”€ Command: ssh -i your-key.pem ubuntu@<PUBLIC_IP>
â”œâ”€ Example: ssh -i D7078E-key.pem ubuntu@13.49.73.251
â””â”€ Verify: Ubuntu prompt appears

âœ“ Success: You're logged into the EC2 instance

Step 1.3: Install Web App
â”œâ”€ Run all these commands in SSH session:
â”‚
â”œâ”€ Update system:
â”‚  â””â”€ sudo apt update && sudo apt upgrade -y
â”‚
â”œâ”€ Install Python:
â”‚  â””â”€ sudo apt install -y python3 python3-pip
â”‚
â”œâ”€ Create app directory:
â”‚  â””â”€ mkdir -p ~/web-app && cd ~/web-app
â”‚
â”œâ”€ Create app.py (copy from task_1.txt or SCREENSHOT_GUIDE.txt)
â”‚  â””â”€ Use: cat > app.py << 'EOF' ... EOF
â”‚
â””â”€ Test the app:
   â””â”€ sudo python3 app.py &

â±ï¸  Wait: 5-10 seconds for app to start
âœ“ Success: "Server running on port 80" message appears

Step 1.4: Test Web App Endpoints (in another SSH terminal or after stopping server)
â”œâ”€ Test 1: curl http://localhost/
â”‚  â””â”€ Should show: HTML with "Welcome to D7078E Cloud Security Lab"
â”‚
â”œâ”€ Test 2: curl http://localhost/metrics
â”‚  â””â”€ Should show: JSON with status and metrics
â”‚
â””â”€ Test 3: curl http://localhost/burn
   â””â”€ Should show: JSON showing CPU work completed (~5 seconds)

âœ“ Success: All three endpoints return 200 OK
ğŸ“¸ Screenshot 2-4: All three curl responses

Step 1.5: Create Systemd Service (Optional but Recommended)
â”œâ”€ This allows the app to auto-start on boot
â”œâ”€ Create service file (copy from task_1.txt)
â”œâ”€ Enable service:
â”‚  â”œâ”€ sudo systemctl daemon-reload
â”‚  â”œâ”€ sudo systemctl enable web-app.service
â”‚  â””â”€ sudo systemctl start web-app.service
â”‚
â””â”€ Verify: sudo systemctl status web-app.service

âœ“ Success: Service shows "active (running)"

Step 1.6: Verify from Local Machine
â”œâ”€ Open Terminal/PowerShell on YOUR COMPUTER (not SSH)
â”œâ”€ Command: curl http://13.49.73.251/
â”œâ”€ Command: curl http://13.49.73.251/metrics
â””â”€ Command: curl http://13.49.73.251/burn

âœ“ Success: All endpoints respond from public IP

Step 1.7: Trigger CPU Spike and Observe in CloudWatch
â”œâ”€ In CloudWatch console:
â”‚  â”œâ”€ Go to: CloudWatch â†’ Metrics
â”‚  â”œâ”€ Select: EC2 â†’ Per-Instance Metrics
â”‚  â”œâ”€ Search for your instance
â”‚  â””â”€ Select: CPUUtilization metric
â”‚
â”œâ”€ Watch the graph show baseline ~5%
â”‚
â”œâ”€ Then run from local terminal:
â”‚  â””â”€ curl http://13.49.73.251/burn
â”‚
â””â”€ Watch CPU spike to 80%+ in CloudWatch, then drop back

â±ï¸  Wait: CPU spike takes ~5-10 seconds to appear in CloudWatch
âœ“ Success: Visible spike in CPU graph
ğŸ“¸ Screenshot 5: CloudWatch CPU spike

Step 1.8: Create AMI from Instance
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Instances
â”œâ”€ Right-click: "web-server-base" instance
â”œâ”€ Click: Image and templates â†’ Create image
â”œâ”€ Name: "web-app-ami-d7078e"
â”œâ”€ Description: "Web app with /burn endpoint for D7078E lab"
â””â”€ Click: Create image

â±ï¸  Wait: 2-5 minutes for AMI to be "Available"
âœ“ Success: AMI shows "Available" status
ğŸ“¸ Screenshot 6: AMI created and available

âœ… TASK 1 COMPLETE!

What you have:
  âœ“ Working web app with 3 endpoints
  âœ“ AMI ready to use: ami-01bb672d521e213d4
  âœ“ Evidence: 6 screenshots

Next: Task 2 - Create infrastructure around this AMI

================================================================================
TASK 2: CREATE ALB + TARGET GROUP + ASG + LAUNCH TEMPLATE
================================================================================

WHAT THIS TASK DOES:
  You'll create the infrastructure to run multiple copies of your web app:
  - Launch Template: Blueprint for launching instances
  - Target Group: Where the load balancer sends traffic
  - Application Load Balancer: Distributes incoming traffic
  - Auto Scaling Group: Runs instances and scales them

STEPS TO COMPLETE:

Step 2.1: Create Launch Template
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Launch Templates â†’ Create launch template
â”œâ”€ Name: "D7078E-MINI-PROJECT-GROUP35-WEBSRV-APP-TEMPLATE"
â”œâ”€ Description: "Template for web app instances"
â”œâ”€ AMI: ami-01bb672d521e213d4 (from Task 1)
â”œâ”€ Instance Type: t2.micro
â”œâ”€ Key Pair: Your key pair
â”œâ”€ Network settings:
â”‚  â””â”€ Security Group: "web-app-asg-sg"
â”‚     â”œâ”€ SSH (22) from your IP
â”‚     â”œâ”€ HTTP (80) from 0.0.0.0/0
â”‚     â””â”€ HTTPS (443) from 0.0.0.0/0
â””â”€ Click: Create launch template

âœ“ Success: Launch template created
ğŸ“¸ Screenshot 7: Launch template visible

Step 2.2: Create Target Group
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Target Groups â†’ Create target group
â”œâ”€ Name: "D7078E-MINI-PROJECT-GROUP35-TG"
â”œâ”€ Protocol: HTTP
â”œâ”€ Port: 80
â”œâ”€ VPC: default
â”œâ”€ Health check settings:
â”‚  â”œâ”€ Protocol: HTTP
â”‚  â”œâ”€ Path: /
â”‚  â”œâ”€ Port: 80
â”‚  â”œâ”€ Interval: 30 seconds
â”‚  â”œâ”€ Timeout: 5 seconds
â”‚  â”œâ”€ Healthy threshold: 2
â”‚  â””â”€ Unhealthy threshold: 3
â””â”€ Click: Create target group

âœ“ Success: Target group created (no targets yet - that's normal)
ğŸ“¸ Screenshot 8: Target group created

Step 2.3: Create Application Load Balancer
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Load Balancers â†’ Create load balancer
â”œâ”€ Choose: Application Load Balancer (ALB)
â”œâ”€ Name: "D7078E-MINI-PROJECT-GROUP35-LB"
â”œâ”€ Scheme: Internet-facing
â”œâ”€ IP address type: IPv4
â”œâ”€ Network mapping:
â”‚  â”œâ”€ VPC: default
â”‚  â””â”€ Availability Zones: Select 2+ (e.g., eu-north-1a, eu-north-1b)
â”œâ”€ Security groups: Create new "alb-sg"
â”‚  â”œâ”€ HTTP (80) from 0.0.0.0/0
â”‚  â””â”€ HTTPS (443) from 0.0.0.0/0
â”œâ”€ Listeners: HTTP (80) - configure later
â””â”€ Click: Create load balancer

â±ï¸  Wait: 1-2 minutes for ALB to reach "Active" state
âœ“ Success: ALB shows "Active" status
ğŸ“¸ Screenshot 9: ALB active
ğŸ“¸ Screenshot 10: Listeners configured

Step 2.4: Attach Target Group to ALB
â”œâ”€ Go to: Load Balancers â†’ Your ALB
â”œâ”€ Click: Listeners tab
â”œâ”€ Click on: HTTP:80 listener
â”œâ”€ Click: Manage rules
â”œâ”€ Set default action: Forward to "D7078E-MINI-PROJECT-GROUP35-TG"
â””â”€ Save changes

âœ“ Success: ALB now sends traffic to target group

Step 2.5: Create Auto Scaling Group
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Auto Scaling Groups â†’ Create Auto Scaling Group
â”œâ”€ Name: "D7078E-MINI-PROJECT-GROUP35-ASG"
â”œâ”€ Launch template: Select "D7078E-MINI-PROJECT-GROUP35-WEBSRV-APP-TEMPLATE"
â”œâ”€ Network:
â”‚  â”œâ”€ VPC: default
â”‚  â””â”€ Subnets: Select 2+ from different AZs
â”œâ”€ Load balancing:
â”‚  â”œâ”€ âœ“ Attach to existing load balancer target group
â”‚  â”œâ”€ Target Group: "D7078E-MINI-PROJECT-GROUP35-TG"
â”‚  â”œâ”€ Health check type: ELB
â”‚  â””â”€ Health check grace period: 300 seconds
â”œâ”€ Group size:
â”‚  â”œâ”€ Desired capacity: 1
â”‚  â”œâ”€ Minimum capacity: 1
â”‚  â””â”€ Maximum capacity: 3
â””â”€ Click: Create Auto Scaling Group

â±ï¸  Wait: 1-2 minutes for first instance to launch and become healthy
âœ“ Success: 1 instance running and healthy
ğŸ“¸ Screenshot 11: ASG with 1 instance
ğŸ“¸ Screenshot 12: Instance management showing healthy

Step 2.6: Verify Instance Registered with Target Group
â”œâ”€ Go to: EC2 â†’ Target Groups â†’ "D7078E-MINI-PROJECT-GROUP35-TG"
â”œâ”€ Click: Targets tab
â”œâ”€ Wait for status to change: initial â†’ draining â†’ healthy

â±ï¸  Wait: 30-60 seconds
âœ“ Success: 1 target showing "Healthy" status
ğŸ“¸ Screenshot 13: Target group with 1 healthy target

Step 2.7: Test ALB Connectivity
â”œâ”€ Go to: Load Balancers â†’ Your ALB
â”œâ”€ Copy: DNS name
â”œâ”€ Open Terminal/PowerShell
â”œâ”€ Test 1: curl http://D7078E-MINI-PROJECT-GROUP35-LB-8834940.eu-north-1.elb.amazonaws.com/
â”‚  â””â”€ Should show: HTML from web app
â”‚
â”œâ”€ Test 2: curl http://D7078E-MINI-PROJECT-GROUP35-LB-8834940.eu-north-1.elb.amazonaws.com/metrics
â”‚  â””â”€ Should show: JSON metrics
â”‚
â””â”€ Test 3: curl http://D7078E-MINI-PROJECT-GROUP35-LB-8834940.eu-north-1.elb.amazonaws.com/burn
   â””â”€ Should show: CPU burn complete

âœ“ Success: All endpoints respond through ALB
ğŸ“¸ Screenshot 14-16: All three curl responses through ALB

âœ… TASK 2 COMPLETE!

What you have:
  âœ“ Launch template configured
  âœ“ Target group with 1 healthy target
  âœ“ ALB active and responding
  âœ“ ASG running 1 instance
  âœ“ Infrastructure ready for scaling
  âœ“ Evidence: 10 screenshots

Next: Task 3 - Configure alarms to trigger auto-scaling

================================================================================
TASK 3: CONFIGURE CLOUDWATCH ALARMS & SCALING POLICIES
================================================================================

WHAT THIS TASK DOES:
  You'll set up CloudWatch alarms that trigger when CPU gets high or low.
  When CPU >= 80%, an alarm will tell ASG to add another instance.
  When CPU <= 30%, an alarm will tell ASG to remove an instance.

STEPS TO COMPLETE:

Step 3.1: Create CloudWatch Dashboard
â”œâ”€ Go to: AWS Console â†’ CloudWatch â†’ Dashboards
â”œâ”€ Click: Create dashboard
â”œâ”€ Name: "D7078E-Lab-Dashboard"
â”œâ”€ Click: Create dashboard
â”œâ”€ Add widgets:
â”‚  â”œâ”€ Widget 1: CPU Utilization
â”‚  â”‚  â”œâ”€ Namespace: AWS/EC2
â”‚  â”‚  â”œâ”€ Dimension: AutoScalingGroupName = D7078E-MINI-PROJECT-GROUP35-ASG
â”‚  â”‚  â””â”€ Metric: CPUUtilization
â”‚  â”‚
â”‚  â”œâ”€ Widget 2: RequestCount
â”‚  â”‚  â”œâ”€ Namespace: AWS/ApplicationELB
â”‚  â”‚  â”œâ”€ Dimension: TargetGroup = D7078E-MINI-PROJECT-GROUP35-TG
â”‚  â”‚  â””â”€ Metric: RequestCount
â”‚  â”‚
â”‚  â””â”€ Widget 3: HealthyHostCount
â”‚     â”œâ”€ Namespace: AWS/ApplicationELB
â”‚     â”œâ”€ Dimension: TargetGroup = D7078E-MINI-PROJECT-GROUP35-TG
â”‚     â””â”€ Metric: HealthyHostCount
â”‚
â””â”€ Save dashboard

âœ“ Success: Dashboard created with baseline metrics
ğŸ“¸ Screenshot 17-20: Dashboard and widgets

Step 3.2: Create Scale-Out Scaling Policy
â”œâ”€ Go to: AWS Console â†’ EC2 â†’ Auto Scaling Groups
â”œâ”€ Click: "D7078E-MINI-PROJECT-GROUP35-ASG"
â”œâ”€ Go to: Automatic scaling tab
â”œâ”€ Click: Create scaling policy
â”œâ”€ Policy name: "scale-out-policy"
â”œâ”€ Policy type: Step Scaling
â”œâ”€ Metric: CPU Utilization
â”œâ”€ Adjustment type: ChangeInCapacity
â”œâ”€ Step adjustments:
â”‚  â””â”€ When metric >= 0: Add 1 instance
â””â”€ Create policy

âœ“ Success: Scale-out policy created
Note: Keep the Policy ARN for next step
ğŸ“¸ Screenshot 21: Scale-out policy

Step 3.3: Create Scale-In Scaling Policy
â”œâ”€ Go to: Automatic scaling tab (same location)
â”œâ”€ Click: Create scaling policy
â”œâ”€ Policy name: "scale-in-policy"
â”œâ”€ Policy type: Step Scaling
â”œâ”€ Metric: CPU Utilization
â”œâ”€ Adjustment type: ChangeInCapacity
â”œâ”€ Step adjustments:
â”‚  â””â”€ When metric <= 0: Remove 1 instance
â””â”€ Create policy

âœ“ Success: Scale-in policy created
Note: Keep the Policy ARN for next step
ğŸ“¸ Screenshot 22: Scale-in policy

Step 3.4: Create CloudWatch Alarm for Scale-Out (80% CPU)
â”œâ”€ Go to: AWS Console â†’ CloudWatch â†’ Alarms â†’ Create alarm
â”œâ”€ Metric selection:
â”‚  â”œâ”€ Namespace: AWS/EC2
â”‚  â”œâ”€ Dimension: AutoScalingGroupName = D7078E-MINI-PROJECT-GROUP35-ASG
â”‚  â””â”€ Metric: CPUUtilization
â”œâ”€ Alarm name: "cpu-high-alarm-80percent"
â”œâ”€ Description: "Triggers scale-out when CPU >= 80%"
â”œâ”€ Statistic: Average
â”œâ”€ Period: 60 seconds (1 minute)
â”œâ”€ Threshold type: Static
â”œâ”€ Threshold: >= 80
â”œâ”€ Evaluation periods: 2 (2 consecutive minutes)
â”œâ”€ Comparison operator: GreaterThanOrEqualToThreshold
â”œâ”€ Alarm state trigger: ALARM (triggers when threshold breached)
â”œâ”€ Actions: Add action â†’ Send to â†’ Select "scale-out-policy"
â””â”€ Create alarm

âœ“ Success: Alarm created and linked to scale-out policy
ğŸ“¸ Screenshot 23: CPU 80% alarm

Step 3.5: Create CloudWatch Alarm for Scale-In (30% CPU)
â”œâ”€ Go to: CloudWatch â†’ Alarms â†’ Create alarm
â”œâ”€ Metric selection:
â”‚  â”œâ”€ Namespace: AWS/EC2
â”‚  â”œâ”€ Dimension: AutoScalingGroupName = D7078E-MINI-PROJECT-GROUP35-ASG
â”‚  â””â”€ Metric: CPUUtilization
â”œâ”€ Alarm name: "cpu-low-alarm-30percent"
â”œâ”€ Description: "Triggers scale-in when CPU <= 30%"
â”œâ”€ Statistic: Average
â”œâ”€ Period: 60 seconds (1 minute)
â”œâ”€ Threshold type: Static
â”œâ”€ Threshold: <= 30
â”œâ”€ Evaluation periods: 5 (5 consecutive minutes)
â”œâ”€ Comparison operator: LessThanOrEqualToThreshold
â”œâ”€ Alarm state trigger: ALARM
â”œâ”€ Actions: Add action â†’ Send to â†’ Select "scale-in-policy"
â””â”€ Create alarm

âœ“ Success: Alarm created and linked to scale-in policy
ğŸ“¸ Screenshot 24: CPU 30% alarm

Step 3.6: Verify Alarms and Policies
â”œâ”€ Go to: EC2 â†’ Auto Scaling Groups â†’ Your ASG
â”œâ”€ Click: Automatic scaling tab
â”‚  â””â”€ Verify: Both "scale-out-policy" and "scale-in-policy" show "Active"
â”‚
â”œâ”€ Go to: CloudWatch â†’ Alarms
â”‚  â”œâ”€ Verify: "cpu-high-alarm-80percent" shows "OK" (not triggered yet)
â”‚  â””â”€ Verify: "cpu-low-alarm-30percent" shows "OK"
â”‚
â””â”€ Go to: CloudWatch Dashboard
   â””â”€ Verify: All 3 widgets show baseline metrics

â±ï¸  Wait: 1-2 minutes for alarms to start reporting metrics
âœ“ Success: Both alarms in "OK" state, both policies "Active"

âœ… TASK 3 COMPLETE!

What you have:
  âœ“ CloudWatch dashboard monitoring metrics
  âœ“ scale-out-policy (adds +1 instance when CPU >= 80%)
  âœ“ scale-in-policy (removes -1 instance when CPU <= 30%)
  âœ“ cpu-high-alarm-80percent (triggers scale-out)
  âœ“ cpu-low-alarm-30percent (triggers scale-in)
  âœ“ Evidence: 8 screenshots

Next: Task 4 - Run load generators to trigger scaling

================================================================================
TASK 4: RUN INTERNAL LOAD GENERATORS - THE MAIN EVENT!
================================================================================

WHAT THIS TASK DOES:
  This is where you PROVE that auto-scaling works!
  You'll run load generators that create HTTP traffic, causing CPU to rise.
  When CPU hits 80%, the alarm triggers and ASG adds another instance.
  You'll scale from 1 â†’ 2 â†’ 3 instances!

PREPARATION (Before starting):

Pre-Check 1: Agent.py file ready
â”œâ”€ Should exist at: /home/steven/Desktop/bridge-between-computer/Mini D7078E/agent.py
â””â”€ âœ“ Verify: File exists and is readable

Pre-Check 2: CloudWatch Dashboard ready
â”œâ”€ Go to: CloudWatch â†’ Dashboards â†’ D7078E-Lab-Dashboard
â”œâ”€ Verify: All 3 widgets visible
â”œâ”€ Tip: Keep this tab OPEN during entire load test!
â””â”€ Set refresh: 10 seconds (for real-time updates)

Pre-Check 3: Python and aiohttp installed
â”œâ”€ Command: python --version
â”‚  â””â”€ Should show: Python 3.8 or higher
â”‚
â””â”€ Command: python -c "import aiohttp"
   â””â”€ Should work without error (if not, run: pip install aiohttp)

STEP-BY-STEP LOAD TEST:

Step 4.1: Take Baseline Screenshot
â”œâ”€ Go to: CloudWatch Dashboard
â”œâ”€ Screenshot: Shows all metrics at baseline
â”‚  â”œâ”€ CPU Utilization: ~5% (idle)
â”‚  â”œâ”€ HealthyHostCount: 1
â”‚  â”œâ”€ RequestCount: ~0
â”‚  â””â”€ All alarms: "OK"
â”‚
â””â”€ This proves the starting state before any load

ğŸ“¸ Screenshot 25: Baseline before load (CRITICAL!)

Step 4.2: START PHASE 1 - Low Load (5 minutes)
â”œâ”€ Open Terminal/PowerShell
â”œâ”€ Command:
â”‚  python agent.py \
â”‚    --url http://D7078E-MINI-PROJECT-GROUP35-LB-8834940.eu-north-1.elb.amazonaws.com/ \
â”‚    --workers 2 \
â”‚    --rps 1 \
â”‚    --duration 300
â”‚
â”œâ”€ What happens:
â”‚  â”œâ”€ 2 workers send 1 request/sec each = 2 RPS total
â”‚  â”œâ”€ Runs for 300 seconds (5 minutes)
â”‚  â”œâ”€ Terminal shows: "Requests sent: X, Successful: Y, Failed: Z"
â”‚  â””â”€ CPU rises to ~20-30%
â”‚
â”œâ”€ Meanwhile in CloudWatch:
â”‚  â”œâ”€ CPU graph shows gradual rise
â”‚  â”œâ”€ RequestCount increases
â”‚  â”œâ”€ HealthyHostCount stays at 1 (no scaling yet)
â”‚  â””â”€ Alarms stay "OK"
â”‚
â””â”€ â±ï¸  Duration: 5 minutes

ğŸ“¸ Screenshot 26: After Phase 1 (5 minutes of load)
  â””â”€ Shows: CPU ~20-30%, 1 instance, low requests

Step 4.3: PHASE 2 - Medium Load (10 minutes)
â”œâ”€ After Phase 1 completes, run:
â”‚  python agent.py \
â”‚    --url http://D7078E-MINI-PROJECT-GROUP35-LB-8834940.eu-north-1.elb.amazonaws.com/ \
â”‚    --workers 10 \
â”‚    --rps 5 \
â”‚    --duration 600
â”‚
â”œâ”€ What happens:
â”‚  â”œâ”€ 10 workers Ã— 5 RPS = 50 RPS total
â”‚  â”œâ”€ Runs for 600 seconds (10 minutes)
â”‚  â”œâ”€ CPU rises toward 60-70%
â”‚  â”œâ”€ Still below 80% threshold
â”‚  â””â”€ No scaling yet (this is normal!)
â”‚
â”œâ”€ Meanwhile in CloudWatch:
â”‚  â”œâ”€ CPU graph shows steeper rise
â”‚  â”œâ”€ RequestCount much higher (50+ RPS)
â”‚  â”œâ”€ HealthyHostCount still 1
â”‚  â””â”€ Alarms still "OK"
â”‚
â””â”€ â±ï¸  Duration: 10 minutes

ğŸ“¸ Screenshot 27: After Phase 2 (10 minutes)
  â””â”€ Shows: CPU 40-60%, still 1 instance, higher requests
  â””â”€ NOT SCALING YET (this is expected!)

Step 4.4: PHASE 3 - High Load (START THE MAGIC!) âœ¨
â”œâ”€ After Phase 2 completes, run:
â”‚  python agent.py \
â”‚    --url http://D7078E-MINI-PROJECT-GROUP35-LB-8834940.eu-north-1.elb.amazonaws.com/ \
â”‚    --workers 30 \
â”‚    --rps 10 \
â”‚    --duration 900
â”‚
â”œâ”€ What happens (CAREFULLY WATCH):
â”‚  â”œâ”€ 30 workers Ã— 10 RPS = 300 RPS total
â”‚  â”œâ”€ CPU RISES SHARPLY toward 80%+
â”‚  â””â”€ GET READY TO WATCH THE SCALING!
â”‚
â”œâ”€ CRITICAL MOMENT - Around minute 7-10:
â”‚  â”œâ”€ CloudWatch: CPU reaches 80% for 2 consecutive minutes
â”‚  â”œâ”€ ALARM TRIGGERS: "cpu-high-alarm-80percent" â†’ "IN_ALARM" (RED!)
â”‚  â”œâ”€ SCALE-OUT ACTIVATED: ASG starts launching instance #2
â”‚  â””â”€ ASG Activity shows: "Launching 1 instance"
â”‚
â”œâ”€ Wait 1-2 minutes:
â”‚  â”œâ”€ New instance boots and becomes "Running"
â”‚  â”œâ”€ Health checks pass
â”‚  â”œâ”€ Instance registers with Target Group
â”‚  â”œâ”€ Status changes: initial â†’ draining â†’ healthy
â”‚  â””â”€ CloudWatch: HealthyHostCount: 1 â†’ 2 âœ¨
â”‚
â”œâ”€ If load still high (CPU >= 80%):
â”‚  â”œâ”€ Wait another 2 minutes
â”‚  â”œâ”€ SECOND ALARM TRIGGER: cpu-high-alarm triggers again
â”‚  â”œâ”€ SCALE-OUT AGAIN: ASG starts launching instance #3
â”‚  â””â”€ ASG Activity shows another: "Launching 1 instance"
â”‚
â”œâ”€ Wait 1-2 more minutes:
â”‚  â”œâ”€ Third instance boots and becomes healthy
â”‚  â”œâ”€ CloudWatch: HealthyHostCount: 2 â†’ 3 âœ¨
â”‚  â””â”€ ASG now at MAX CAPACITY (3 instances, desired = 3)
â”‚
â”œâ”€ Load distributes across 3 instances:
â”‚  â”œâ”€ CPU may drop slightly (more resources available)
â”‚  â”œâ”€ But still processes ALL requests
â”‚  â”œâ”€ System handling peak load gracefully
â”‚  â””â”€ All 3 instances healthy
â”‚
â””â”€ â±ï¸  Duration: ~15 minutes (watch closely during this phase!)

CRITICAL SCREENSHOTS - TAKE THESE! ğŸ¬

ğŸ“¸ Screenshot 28: CPU alarm triggered at 80%
  â””â”€ Shows: cpu-high-alarm-80percent state = "IN_ALARM" (RED!)
  â””â”€ This is the TRIGGER MOMENT!

ğŸ“¸ Screenshot 29: First scaling event
  â””â”€ Go to: EC2 â†’ Auto Scaling Groups â†’ Your ASG â†’ Activity tab
  â””â”€ Shows: "Launching 1 instance to replace unhealthy instance" (or similar)
  â””â”€ Shows: Timestamp when scaling triggered

ğŸ“¸ Screenshot 30: Instance 2 becoming healthy
  â””â”€ Go to: EC2 â†’ Target Groups â†’ Your TG â†’ Targets tab
  â””â”€ Shows: 2 targets, one transitioning to "Healthy"
  â””â”€ CloudWatch: HealthyHostCount rises to 2

ğŸ“¸ Screenshot 31: High load with 2 instances
  â””â”€ Go to: CloudWatch Dashboard
  â””â”€ Shows: CPU still high, HealthyHostCount = 2, high RequestCount

ğŸ“¸ Screenshot 32: Second scaling event
  â””â”€ Go to: EC2 â†’ Auto Scaling Groups â†’ Activity tab
  â””â”€ Shows: Another "Launching 1 instance"
  â””â”€ Shows: Timestamp of second scaling

ğŸ“¸ Screenshot 33: All 3 instances healthy
  â””â”€ Go to: EC2 â†’ Target Groups â†’ Targets tab
  â””â”€ Shows: 3 targets all "Healthy"
  â””â”€ CloudWatch: HealthyHostCount = 3 (MAXIMUM!)

ğŸ“¸ Screenshot 34: All 3 instances running in EC2
  â””â”€ Go to: EC2 â†’ Instances
  â””â”€ Shows: 3 instances all "Running"
  â””â”€ Shows: Instance IDs, launch times, status checks passing

ğŸ“¸ Screenshot 35: ASG at capacity
  â””â”€ Go to: EC2 â†’ Auto Scaling Groups â†’ Your ASG
  â””â”€ Shows: Desired: 3, Current: 3, Min: 1, Max: 3
  â””â”€ Shows: 3 instances in "InService"

ğŸ“¸ Screenshot 36: Peak load metrics
  â””â”€ Go to: CloudWatch Dashboard
  â””â”€ Shows: CPU distributed across 3 instances
  â””â”€ Shows: High RequestCount
  â””â”€ Shows: All 3 instances healthy
  â””â”€ Shows: Smooth operation

Step 4.5: OBSERVE SCALE-IN (Optional - if you want to see it)
â”œâ”€ After Phase 3 completes, stop the load generator
â”‚  â””â”€ Load drops to 0 RPS
â”‚
â”œâ”€ Watch CloudWatch:
â”‚  â”œâ”€ CPU drops below 80%
â”‚  â”œâ”€ cpu-high-alarm transitions: "IN_ALARM" â†’ "OK"
â”‚  â”œâ”€ RequestCount drops to 0
â”‚  â””â”€ System quiets down
â”‚
â”œâ”€ Wait 5+ minutes:
â”‚  â”œâ”€ CloudWatch: cpu-low-alarm-30percent conditions met
â”‚  â”œâ”€ Alarm triggers: cpu-low-alarm â†’ "IN_ALARM"
â”‚  â”œâ”€ Scale-in starts: Instance removed
â”‚  â”œâ”€ HealthyHostCount: 3 â†’ 2 â†’ 1
â”‚  â””â”€ Takes ~10-15 minutes total from load stopping
â”‚
â””â”€ Note: Scale-in is slower by design (prevents flapping)

Optional: ğŸ“¸ Screenshot 37: Load test complete (after scale-in)
  â””â”€ Shows: HealthyHostCount back to 1
  â””â”€ Shows: CPU back to baseline
  â””â”€ Shows: Complete lifecycle

âœ… TASK 4 COMPLETE!

What you have:
  âœ“ Proven auto-scaling works
  âœ“ Instances scaled 1 â†’ 2 â†’ 3
  âœ“ CloudWatch alarms triggered at 80% CPU
  âœ“ Metrics showing successful scaling
  âœ“ Evidence: 13 screenshots (6 CRITICAL ones minimum)

What you learned:
  âœ“ AWS auto-scaling is automatic and effective
  âœ“ New instances start up quickly
  âœ“ Load distributes evenly
  âœ“ System handles peaks gracefully
  âœ“ No manual intervention needed

Next: Task 5 (Optional) - Simulate failure OR Task 6 - Cleanup & Report

================================================================================
TASK 5: SAFE FAILURE SIMULATION (OPTIONAL)
================================================================================

WHAT THIS TASK DOES:
  You'll deliberately crash one instance to show that the system
  automatically detects the failure and replaces it.
  
Requirements:
  âœ“ Task 4 complete with 3 instances running
  âœ“ All 3 instances healthy
  âœ“ CloudWatch dashboard ready

STEPS TO COMPLETE:

Step 5.1: Verify 3 Healthy Instances
â”œâ”€ Go to: EC2 â†’ Target Groups â†’ Your TG â†’ Targets tab
â”œâ”€ Verify: All 3 targets show "Healthy"
â”œâ”€ Go to: CloudWatch Dashboard
â”œâ”€ Verify: HealthyHostCount = 3
â””â”€ ğŸ“¸ Screenshot 38: Before failure (3 healthy)

Step 5.2: Choose How to Simulate Failure
â”œâ”€ Option A: AWS Fault Injection Simulator (FIS)
â”‚  â””â”€ More professional, but requires setup
â”‚
â”œâ”€ Option B: SSM Stress Command (RECOMMENDED)
â”‚  â””â”€ Simpler, automatic timeout, perfect for lab
â”‚
â””â”€ Option C: Direct SSH
   â””â”€ Most manual, requires SSH setup

Using Option B (SSM Stress - RECOMMENDED):

Step 5.3: Run Stress Command on One Instance
â”œâ”€ Go to: EC2 â†’ Instances
â”œâ”€ Pick ONE instance to stress
â”œâ”€ Copy its Instance ID (example: i-0a1b2c3d4e5f6g7h8)
â”œâ”€ Open Terminal/PowerShell
â”œâ”€ Run command:
â”‚
â”‚  aws ssm send-command \
â”‚    --instance-ids i-YOUR_INSTANCE_ID \
â”‚    --document-name "AWS-RunShellScript" \
â”‚    --parameters 'commands=["sudo apt-get update -y","sudo apt-get install -y stress-ng","stress-ng -c 0 -l 90 -t 120s"]' \
â”‚    --region eu-north-1
â”‚
â”œâ”€ Expected output: CommandId appears
â””â”€ Note: Command will run for 120 seconds, then stop automatically (safe!)

Step 5.4: WATCH THE FAILURE IN REAL TIME! ğŸ‘€

Timeline (2-3 minutes):

Minute 0:
â”œâ”€ ğŸ“¸ Screenshot 39: Stress command starts
â””â”€ Terminal shows: Command executing on instance

Minute 0-0.5:
â”œâ”€ CloudWatch: CPU on stressed instance spikes to 90%
â”œâ”€ Instance becomes non-responsive (too busy with CPU work)
â””â”€ Application timeout happens

Minute 0.5-1:
â”œâ”€ ğŸ“¸ Screenshot 40: Health check fails
â”œâ”€ EC2 â†’ Target Groups: One instance status â†’ "Unhealthy"
â”œâ”€ HealthyHostCount: 3 â†’ 2 (one removed from traffic!)
â”œâ”€ ALB stops sending traffic to unhealthy instance
â””â”€ Requests now handled by 2 healthy instances

Minute 1:
â”œâ”€ ASG detects unhealthy instance
â”œâ”€ ğŸ“¸ Screenshot 41: Replacement launching
â”œâ”€ EC2 â†’ Auto Scaling Groups â†’ Activity tab shows:
â”‚  â””â”€ "Launching 1 instance to replace unhealthy instance"
â””â”€ New instance ID appears

Minute 1-2:
â”œâ”€ ğŸ“¸ Screenshot 42: CPU spike visible
â”œâ”€ CloudWatch Dashboard shows:
â”‚  â”œâ”€ One instance at 90% CPU
â”‚  â”œâ”€ Two instances at normal CPU
â”‚  â”œâ”€ Overall average CPU moderate
â”‚  â””â”€ System still handling requests from 2 healthy instances
â”œâ”€ No errors! Users still getting responses!
â””â”€ This shows HIGH AVAILABILITY in action!

Minute 2:
â”œâ”€ Stress-ng completes (120 seconds end)
â”œâ”€ Stressed instance CPU drops from 90% â†’ 5%
â”œâ”€ But still marked "Unhealthy" (recovery takes time)
â””â”€ Replacement instance still booting

Minute 2-2.5:
â”œâ”€ Replacement instance finishes booting
â”œâ”€ Health checks begin passing
â”œâ”€ ğŸ“¸ Screenshot 43: Replacement healthy!
â”œâ”€ Target status: "Healthy"
â”œâ”€ HealthyHostCount: 2 â†’ 3 (RECOVERY!)
â”œâ”€ Old unhealthy instance terminates
â””â”€ System fully restored!

Minute 3+:
â”œâ”€ ğŸ“¸ Screenshot 44: System recovered
â”œâ”€ All metrics normal
â”œâ”€ All 3 instances healthy
â”œâ”€ Total recovery time: ~3 minutes
â””â”€ NO MANUAL ACTION NEEDED! âœ¨

Step 5.5: Document the Recovery
â”œâ”€ ğŸ“¸ Screenshot 45: ASG activity log
â”‚  â””â”€ Shows complete failure â†’ recovery timeline
â”‚
â”œâ”€ Record these metrics:
â”‚  â”œâ”€ Time to detect failure: _____ seconds
â”‚  â”œâ”€ Time to launch replacement: _____ minutes
â”‚  â”œâ”€ Time for replacement to be healthy: _____ minutes
â”‚  â”œâ”€ Total recovery time: _____ minutes
â”‚  â””â”€ Downtime experienced: None (2/3 capacity handled traffic)
â”‚
â””â”€ Key finding: AUTOMATIC FAILOVER! No human intervention!

âœ… TASK 5 COMPLETE! (Optional but recommended)

What you learned:
  âœ“ Health checks detect failures automatically
  âœ“ ASG replaces failed instances automatically
  âœ“ System remains available during failure (2/3 capacity)
  âœ“ Recovery is automatic and fast (~3 minutes)
  âœ“ This is what high availability means!

Next: Task 6 - Cleanup and write lab report

================================================================================
TASK 6: TEARDOWN, CLEANUP & FINAL DOCUMENTATION
================================================================================

WHAT THIS TASK DOES:
  You'll delete all AWS resources and write a comprehensive lab report.
  This is REQUIRED - leaving resources running costs money!

STEPS TO COMPLETE:

Step 6.1: Collect Final Evidence
â”œâ”€ ğŸ“¸ Screenshot 46: Final metrics
â”‚  â””â”€ Go to: CloudWatch Dashboard
â”‚  â””â”€ Shows: Complete test history in graphs
â”‚
â”œâ”€ ğŸ“¸ Screenshot 47: Complete ASG activity log
â”‚  â””â”€ Go to: EC2 â†’ Auto Scaling Groups â†’ Activity tab
â”‚  â””â”€ Shows: All scaling events from start to finish
â”‚  â””â”€ Shows: Timestamps of each event
â”‚
â””â”€ Record CloudTrail logs (optional but professional)
   â””â”€ Go to: CloudTrail â†’ Event history
   â””â”€ Download as JSON

Step 6.2: Stop Any Running Load Generators
â”œâ”€ If load generator still running in Terminal:
â”‚  â””â”€ Press Ctrl+C to stop
â”œâ”€ Wait 30 seconds for graceful shutdown
â””â”€ Verify: Requests drop to 0 in CloudWatch

Step 6.3: Delete Auto Scaling Group
â”œâ”€ Go to: EC2 â†’ Auto Scaling Groups
â”œâ”€ Select: "D7078E-MINI-PROJECT-GROUP35-ASG"
â”œâ”€ Click: Delete Auto Scaling group
â”œâ”€ Confirmation dialog:
â”‚  â”œâ”€ Check: "Yes, terminate instances when deleting"
â”‚  â””â”€ Click: Delete
â”‚
â”œâ”€ â±ï¸  Wait: 1-2 minutes
â”œâ”€ Verify: ASG disappears from list
â”œâ”€ Verify: Instances status changes to "Terminated"
â””â”€ ğŸ“¸ Screenshot 48: ASG deleted

Step 6.4: Delete Application Load Balancer
â”œâ”€ Go to: EC2 â†’ Load Balancers
â”œâ”€ Select: "D7078E-MINI-PROJECT-GROUP35-LB"
â”œâ”€ Click: Delete
â”œâ”€ Confirmation: Click Yes
â”‚
â”œâ”€ â±ï¸  Wait: 1-2 minutes
â””â”€ ğŸ“¸ Screenshot 49: ALB deleted

Step 6.5: Delete Target Group
â”œâ”€ Go to: EC2 â†’ Target Groups
â”œâ”€ Select: "D7078E-MINI-PROJECT-GROUP35-TG"
â”œâ”€ Click: Delete
â”œâ”€ Confirmation: Click Yes
â””â”€ ğŸ“¸ Screenshot 50: TG deleted

Step 6.6: Delete Launch Template
â”œâ”€ Go to: EC2 â†’ Launch Templates
â”œâ”€ Select: "D7078E-MINI-PROJECT-GROUP35-WEBSRV-APP-TEMPLATE"
â”œâ”€ Click: Delete
â”œâ”€ Confirmation: Click Yes
â””â”€ ğŸ“¸ Screenshot 51: Template deleted

Step 6.7: Verify All Resources Deleted
â”œâ”€ EC2 â†’ Instances: No instances running from this lab
â”œâ”€ EC2 â†’ Load Balancers: No ALB from this lab
â”œâ”€ EC2 â†’ Target Groups: No TG from this lab
â”œâ”€ EC2 â†’ Auto Scaling Groups: No ASG from this lab
â”œâ”€ EC2 â†’ Launch Templates: No template from this lab
â””â”€ ğŸ“¸ Screenshot 52: Everything cleaned up

Step 6.8: Write Lab Report (20-30 pages!)
â”œâ”€ Create document: "D7078E-Lab-Report.pdf"
â”œâ”€ Include sections:
â”‚  â”œâ”€ Title page (Name, Date, Student ID)
â”‚  â”œâ”€ Executive Summary (1 page)
â”‚  â”œâ”€ Objectives (what you aimed to do)
â”‚  â”œâ”€ Architecture Diagram (show the setup)
â”‚  â”œâ”€ Methodology (how you did it)
â”‚  â”œâ”€ Results (5-10 pages with screenshots)
â”‚  â”‚  â”œâ”€ Task 1 results + screenshots
â”‚  â”‚  â”œâ”€ Task 2 results + screenshots
â”‚  â”‚  â”œâ”€ Task 3 results + screenshots
â”‚  â”‚  â”œâ”€ Task 4 results + screenshots (MOST IMPORTANT!)
â”‚  â”‚  â””â”€ Task 5 results + screenshots (if done)
â”‚  â”œâ”€ Analysis & Observations (3-5 pages)
â”‚  â”‚  â”œâ”€ How long did scaling take?
â”‚  â”‚  â”œâ”€ Peak metrics achieved?
â”‚  â”‚  â”œâ”€ Was any data lost?
â”‚  â”‚  â””â”€ System behavior observations
â”‚  â”œâ”€ Lessons Learned (2-3 pages)
â”‚  â”‚  â”œâ”€ What worked well?
â”‚  â”‚  â”œâ”€ What were challenges?
â”‚  â”‚  â”œâ”€ Production implications?
â”‚  â”‚  â””â”€ Recommendations for improvement
â”‚  â”œâ”€ Conclusions (1 page)
â”‚  â””â”€ Appendices (screenshots, logs, commands)
â”‚
â””â”€ Include: All 50+ screenshots organized by task

Step 6.9: Create Summary Document
â”œâ”€ File: "Lab-Summary.txt"
â”œâ”€ Include:
â”‚  â”œâ”€ All AWS resource IDs used
â”‚  â”œâ”€ Timeline of events (with exact timestamps)
â”‚  â”œâ”€ Key metrics achieved:
â”‚  â”‚  â”œâ”€ Peak CPU: ____%
â”‚  â”‚  â”œâ”€ Peak RPS: _____ requests/second
â”‚  â”‚  â”œâ”€ Instances scaled to: 3
â”‚  â”‚  â”œâ”€ Scaling time: _____ minutes
â”‚  â”‚  â””â”€ Recovery time (if Task 5): _____ minutes
â”‚  â”œâ”€ Cost summary
â”‚  â””â”€ Conclusions
â”‚
â””â”€ This is a quick reference for your report

Step 6.10: Organize All Evidence
â”œâ”€ Folder structure:
â”‚  â”œâ”€ Screenshots/ (all 50+ screenshots organized by task)
â”‚  â”œâ”€ Configuration/ (AMI IDs, resource IDs, ARNs)
â”‚  â”œâ”€ CloudTrail/ (event logs)
â”‚  â””â”€ Code/ (agent.py, docker-compose.yml, etc.)
â”‚
â””â”€ Everything referenced in your lab report

âœ… TASK 6 COMPLETE!

What you have:
  âœ“ All AWS resources deleted (cost savings!)
  âœ“ Comprehensive lab report (20-30 pages)
  âœ“ Complete evidence (50+ screenshots)
  âœ“ Detailed timeline and metrics
  âœ“ Professional documentation

================================================================================
SUMMARY: YOU'VE COMPLETED A FULL LAB!
================================================================================

What you accomplished:
  âœ… TASK 1: Built web app AMI
  âœ… TASK 2: Created infrastructure (ALB, TG, ASG)
  âœ… TASK 3: Configured auto-scaling alarms
  âœ… TASK 4: Demonstrated scaling 1 â†’ 2 â†’ 3 instances
  â³ TASK 5: Simulated failure and recovery (optional)
  âœ… TASK 6: Cleaned up and documented everything

Key skills demonstrated:
  âœ“ AWS cloud architecture
  âœ“ EC2, ALB, ASG configuration
  âœ“ CloudWatch monitoring and alarms
  âœ“ Load testing and performance analysis
  âœ“ Automatic scaling and failover
  âœ“ Professional documentation

Total effort:
  â”œâ”€ Tasks 1-4: ~3-4 hours
  â”œâ”€ Task 5: ~20 minutes (optional)
  â”œâ”€ Task 6: ~1-2 hours
  â””â”€ Total: ~5-6 hours for complete lab

NEXT STEPS:
  1. Review your lab report
  2. Double-check all screenshots are clear
  3. Verify all conclusions are accurate
  4. Submit to instructor
  5. Feel proud of your cloud engineering skills! ğŸ‰

Good luck with your submission!

================================================================================
