================================================================================
D7078E CLOUD SECURITY MINI PROJECT
VIDEO PRESENTATION SCRIPT
Group 35
Date: January 6, 2026
================================================================================

TOTAL VIDEO LENGTH: 15-20 minutes
Format: Screen recording with voice-over narration

================================================================================
SECTION 1: INTRODUCTION (1-2 minutes)
================================================================================

[SLIDE/SCREEN: Title Card]

NARRATION:
"Hello, I'm presenting the D7078E Cloud Security Mini Project completed by 
Group 35. In this video, I'll walk you through how we designed, deployed, 
and tested a resilient, auto-scaling cloud infrastructure on Amazon Web Services.

This project demonstrates five key cloud engineering concepts:
1. Infrastructure automation with EC2, ALB, and Auto Scaling Groups
2. Automatic scaling based on CPU utilization metrics
3. Health-based instance replacement
4. Controlled load testing
5. Failure simulation and automatic recovery

Let's begin."

[TIME: 0:00 - 1:30]

================================================================================
SECTION 2: PROJECT OVERVIEW & ARCHITECTURE (2-3 minutes)
================================================================================

[SCREEN: Show architecture diagram or draw it]

NARRATION:
"Our architecture consists of several key components:

First, we have load generators - Python-based agents running in Docker 
containers that simulate realistic HTTP traffic.

These requests flow through an Application Load Balancer, which distributes 
traffic evenly across multiple EC2 instances.

The EC2 instances run our custom Python web application with three endpoints:
- A home page
- A metrics endpoint
- A CPU-intensive endpoint used for load generation

All instances are managed by an Auto Scaling Group with:
- Minimum capacity: 1 instance
- Desired capacity: starts at 1, scales up to 3
- Maximum capacity: 3 instances

CloudWatch continuously monitors CPU utilization, request count, and host 
health. When CPU reaches 80% for 2 minutes, the system automatically scales 
out and adds a new instance.

When CPU drops below 30% for 5 minutes, the system scales in and removes 
an instance, but always maintains at least 1 running.

This is achieved through two CloudWatch alarms connected to Auto Scaling 
policies - all automatic, no manual intervention required."

[TIME: 1:30 - 4:30]

================================================================================
SECTION 3: TASK 1 - WEB APP AMI PREPARATION (1-2 minutes)
================================================================================

[SCREEN: Show EC2 Dashboard with running instance]
[SCREEN: Show web app responding in browser]
[SCREEN: Show CloudWatch CPU metrics]
[SCREEN: Show AMI creation screen]

NARRATION:
"Task 1 involved creating a custom Amazon Machine Image containing our web 
application.

We launched an EC2 instance running Ubuntu 22.04 LTS and installed a Python 
HTTP server that serves three endpoints. The root endpoint shows a simple 
HTML page. The /metrics endpoint returns JSON with server statistics. 
And the /burn endpoint performs a CPU-intensive calculation for 5 seconds 
to simulate high load.

We configured this application to run automatically on instance startup 
using systemd service.

Once we verified all endpoints worked correctly, we created an AMI from this 
instance. This AMI becomes the blueprint that the Auto Scaling Group uses 
to launch new instances. This ensures every instance launched is consistent 
and properly configured.

AMI ID: ami-01bb672d521e213d4"

[TIME: 4:30 - 6:15]

================================================================================
SECTION 4: TASK 2 - INFRASTRUCTURE SETUP (2-3 minutes)
================================================================================

[SCREEN: Show Launch Template details]
[SCREEN: Show ALB creation and status - Active]
[SCREEN: Show Target Group with healthy targets]
[SCREEN: Show ASG with running instance]
[SCREEN: Show curl output from ALB endpoint]

NARRATION:
"Task 2 was about building the complete infrastructure stack.

First, we created a Launch Template. This is a reusable blueprint that 
specifies how the Auto Scaling Group should launch new instances. It 
references our AMI from Task 1, specifies t2.micro instance type, and 
configures security groups.

Next, we created the Target Group. This defines a logical grouping of 
instances that receive traffic. We configured health checks to run every 
30 seconds, with a 5-second timeout. An instance is marked healthy after 
2 consecutive successful checks, and unhealthy after 3 failures.

Then we created the Application Load Balancer across multiple availability 
zones for high availability. This distributes incoming traffic and performs 
the health checks we defined.

Finally, we created the Auto Scaling Group, set it to use our Launch Template, 
attached it to our Target Group, and configured initial capacity: 
minimum 1, desired 1, maximum 3.

Within seconds, the ASG launched our first instance. We verified it 
registered as healthy in the Target Group.

Then we tested end-to-end connectivity by curling the ALB DNS name - 
success! Traffic flows from ALB to our instance."

[TIME: 6:15 - 9:15]

================================================================================
SECTION 5: TASK 3 - SCALING POLICIES & ALARMS (1.5-2 minutes)
================================================================================

[SCREEN: Show CloudWatch Dashboard]
[SCREEN: Show Scaling Policies list]
[SCREEN: Show CloudWatch Alarms in OK state]
[SCREEN: Show alarm configuration details]

NARRATION:
"Task 3 configured the automatic scaling logic.

We created two AWS Auto Scaling policies:
- Scale-out policy: adds 1 instance when triggered
- Scale-in policy: removes 1 instance when triggered

These policies are triggered by two CloudWatch alarms.

The CPU-high alarm triggers when average CPU utilization is greater than 
or equal to 80% for 2 consecutive 1-minute periods. That's 2 minutes of 
sustained high CPU before scaling out.

The CPU-low alarm triggers when average CPU utilization is less than or 
equal to 30% for 5 consecutive 1-minute periods. That's 5 minutes of low 
CPU before scaling in - this prevents unnecessary up-and-down cycling.

We created a CloudWatch dashboard to visualize these metrics in real-time:
- CPU Utilization - the key metric driving scaling
- RequestCount - shows how much load we're putting on the system
- HealthyHostCount - shows available instances
- UnhealthyHostCount - shows failed instances

All alarms were initially in OK state, ready to trigger when we run the 
load test."

[TIME: 9:15 - 11:00]

================================================================================
SECTION 6: TASK 4 - LOAD TESTING & SCALING DEMONSTRATION (4-5 minutes)
================================================================================

[SCREEN: Open CloudWatch Dashboard in browser]
[SCREEN: Start showing load test phases with dashboard updates]

NARRATION:
"Task 4 is where the magic happens - we run load tests to demonstrate 
automatic scaling.

We developed a Python-based load generator using asyncio for asynchronous 
HTTP requests. We containerized it with Docker and used docker-compose 
to run multiple instances simultaneously.

The load test has three phases, each gradually increasing the traffic.

[PHASE 1 DEMONSTRATION]
In Phase 1, we run low load - just 2 requests per second from 1 container. 
Watch the CloudWatch dashboard:
- CPU rises to about 20-30%
- HealthyHostCount stays at 1
- No scaling occurs because we're below 80% threshold

This establishes our baseline.

[PHASE 2 DEMONSTRATION]
In Phase 2, we increase load to medium - 6 requests per second from 3 
containers. 
- CPU rises to about 50-70%
- Still just 1 instance
- Still below the 80% threshold
- No scaling yet

This tests system performance under normal-high load.

[PHASE 3 DEMONSTRATION]
In Phase 3, the real test begins - we run 10+ requests per second from 5 
containers.

Watch what happens:
- CPU rapidly climbs toward 80%
- At the 2-minute mark with sustained high CPU, the alarm triggers
- cpu-high-alarm-80percent transitions from OK to IN_ALARM
- The scale-out policy executes automatically
- A new instance launches - you can see HealthyHostCount go from 1 to 2

The load distributes across 2 instances, but CPU still stays high because 
load is still heavy.

A few minutes later, another scaling event:
- Second scale-out triggers
- HealthyHostCount goes from 2 to 3
- Now load distributes across all 3 instances

The system reached maximum capacity automatically, maintaining service 
availability throughout.

Total time from alarm trigger to having all 3 instances healthy: 
approximately 2-3 minutes.

RequestCount shows all traffic succeeded - zero failed requests during scaling.

This demonstrates that AWS Auto Scaling works exactly as designed - 
capacity automatically adjusts to match demand without manual intervention."

[TIME: 11:00 - 15:30]

================================================================================
SECTION 7: TASK 5 - FAILURE SIMULATION & RECOVERY (2-3 minutes)
================================================================================

[SCREEN: Show 3 healthy instances before failure]
[SCREEN: Show failure simulation starting]
[SCREEN: Show instance health status changing]
[SCREEN: Show metrics during failure]
[SCREEN: Show new instance launching]
[SCREEN: Show recovery completing]

NARRATION:
"Task 5 demonstrates resilience - what happens when an instance fails.

We intentionally caused a failure by running the stress-ng tool with 90% 
CPU load for 120 seconds on one instance.

Watch the timeline:

[T+0 seconds] Stress-ng starts on one instance
- That instance's CPU immediately spikes to 90%
- The other 2 instances continue normal operation

[T+10-30 seconds] Health checks start failing
- The ALB tries to reach the stressed instance
- It's too busy to respond in time
- Health check fails

[T+30 seconds] Instance marked unhealthy
- Target Group removes it from service
- ALB stops sending new traffic to it
- But the instance is still running

[T+45 seconds] ASG detects the unhealthy instance
- It immediately launches a replacement instance

[T+60 seconds] New instance boots
- Enters running state

[T+90 seconds] New instance passes health checks
- Marked as healthy
- Starts receiving traffic

[T+120 seconds] Stress-ng completes - stressed instance recovers
- CPU drops back to normal

[T+150 seconds] Original instance terminates
- ASG replaces it with the healthy new instance

[T+180+ seconds] Full recovery
- Back to 3 healthy instances
- All traffic flowing normally

Total recovery time: 2-3 minutes
System availability during failure: 66% (2 healthy out of 3)
Zero manual intervention: All automatic

This demonstrates production-grade resilience. The system detected a failure, 
removed the unhealthy instance from service, launched a replacement, and 
recovered completely - all without anyone doing anything.

Users experienced minimal disruption because 2 of 3 instances continued 
serving requests."

[TIME: 15:30 - 18:30]

================================================================================
SECTION 8: TASK 6 - CLEANUP & SUMMARY (1-2 minutes)
================================================================================

[SCREEN: Show resource deletion in AWS Console]
[SCREEN: Show final empty state]

NARRATION:
"Task 6 is cleanup and documentation.

After testing, we systematically deleted all AWS resources:
- First, the Auto Scaling Group - this terminates all instances
- Then the Application Load Balancer
- Then the Target Group
- Then the Launch Template
- Finally, security groups

This prevents ongoing costs. Each instance was costing about 1 cent per hour, 
and the ALB was costing about 2.25 cents per hour. By cleaning up promptly, 
we saved money.

All resources are now deleted and verified gone from AWS."

[TIME: 18:30 - 19:30]

================================================================================
SECTION 9: KEY FINDINGS & CONCLUSION (1 minute)
================================================================================

[SCREEN: Show summary slide or key metrics]

NARRATION:
"Let me summarize what this project demonstrated:

KEY FINDINGS:

1. Auto-scaling works reliably
   - Triggered at precisely 80% CPU threshold
   - Added instances within 2-3 minutes
   - Removed instances after sustained low load

2. Health checks are effective
   - Detected failure within 30 seconds
   - Prevented further traffic to failed instance
   - Triggered automatic replacement

3. Load balancing distributes evenly
   - Traffic split fairly across instances
   - No single instance overloaded
   - Linear scalability

4. System remained available
   - During scaling: full availability
   - During failure: 66% availability (2/3 healthy)
   - Zero manual intervention required

5. Zero downtime was achieved
   - Users never saw service unavailable
   - Requests automatically rerouted
   - Recovery happened automatically

This architecture is production-ready and suitable for real applications 
requiring high availability.

Thank you for watching. This concludes the D7078E Cloud Security Mini 
Project presentation."

[TIME: 19:30 - 20:30]

================================================================================
TECHNICAL NOTES FOR VIDEO RECORDING
================================================================================

BEST PRACTICES:

1. Screen recording settings:
   - 1920x1080 resolution
   - 30 FPS
   - High bitrate for clarity
   - Use a good microphone for clear narration

2. What to show on screen:
   - AWS Console dashboards and resources
   - CloudWatch metrics in real-time during load test
   - Terminal/CLI output
   - Diagrams or architecture drawings

3. Pacing:
   - Speak clearly and at reasonable pace
   - Pause briefly between sections
   - Allow metrics time to update on screen
   - Don't rush through the critical sections (4 and 5)

4. Audio:
   - Record in quiet environment
   - Use clear, professional tone
   - Test audio levels before full recording

5. Editing tips:
   - Speed up non-critical parts (e.g., waiting for instances to launch)
   - Use captions/titles for AWS Console navigation
   - Highlight key metrics with arrows or annotations
   - Add timestamps for easy reference

CRITICAL MOMENTS TO CAPTURE:

- [Task 1] Web app responding to all three endpoints
- [Task 2] ALB transitioning to Active state
- [Task 2] Target Group showing healthy target
- [Task 3] Alarms in OK state before load test
- [Task 4] CPU rising to 80% threshold
- [Task 4] Alarm triggering (OK → IN_ALARM)
- [Task 4] HealthyHostCount increasing (1→2→3)
- [Task 4] RequestCount showing load increase
- [Task 5] Instance health status changing
- [Task 5] HealthyHostCount dropping then recovering
- [Task 5] Final recovery with all 3 instances healthy

APPROXIMATE TIME ALLOCATION:

- Introduction: 1-2 minutes
- Overview: 2-3 minutes
- Task 1: 1-2 minutes
- Task 2: 2-3 minutes
- Task 3: 1.5-2 minutes
- Task 4: 4-5 minutes (longest section - most important)
- Task 5: 2-3 minutes
- Task 6: 1-2 minutes
- Conclusion: 1 minute

TOTAL: 15-20 minutes

================================================================================
SCRIPT FORMATTING NOTES
================================================================================

[SCREEN: ...] = Indicates what should be visible on screen
[TIME: ...] = Indicates timing in video
NARRATION: = Spoken text
[PHASE ... DEMONSTRATION] = Indicates live system demonstration

For recording: Pause between sections to allow time for screen transitions.
Speak the narration clearly with good pacing.
Let dashboard animations complete before continuing.

================================================================================
END OF PRESENTATION SCRIPT
================================================================================
