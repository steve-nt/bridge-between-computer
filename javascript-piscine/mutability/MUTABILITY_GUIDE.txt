================================================================================
                    JAVASCRIPT MUTABILITY - IMPLEMENTATION GUIDE
                        Understanding Object Copies in JavaScript
================================================================================

WHAT IS THIS ASSIGNMENT ABOUT?
================================================================================

Imagine you have a recipe card for your favorite pizza. Now imagine three 
scenarios:

1. You photocopy the recipe exactly - if you spill coffee on your original 
   recipe, the copy stays clean (CLONE1 and CLONE2)
2. You tear out the page and give it to your friend - now you both have the 
   SAME physical page. If your friend marks it up, you see the same marks 
   (SAMEPERSON)

This assignment teaches you the difference between these two scenarios in 
JavaScript. When you work with objects, you need to understand whether you're 
creating a new independent copy or just pointing to the same object.


KEY CONCEPTS TO UNDERSTAND
================================================================================

1. OBJECTS IN JAVASCRIPT ARE REFERENCES
   ---
   In JavaScript, when you create an object like:
   const person = { name: 'Rick', age: 77, country: 'US' }
   
   The variable 'person' doesn't actually HOLD the object - it holds a 
   REFERENCE (like a pointer or address) to where that object lives in memory.
   
   When you assign person to another variable:
   const samePerson = person
   
   You're NOT copying the object. You're just creating a new label that points 
   to THE SAME OBJECT in memory. Think of it like having two name tags on the 
   same person!


2. SHALLOW COPY vs DEEP COPY
   ---
   SHALLOW COPY: Creates a new object, but doesn't create new copies of 
   objects inside it. It's like copying just the outer layer.
   
   DEEP COPY: Creates a new object AND copies everything inside it. It's like 
   making a complete photocopy, not just tracing the outline.


3. MUTABILITY
   ---
   "Mutable" means "can be changed". Objects in JavaScript are mutable - you 
   can change their properties after creation. This is different from strings 
   or numbers, which are immutable (can't be changed once created).


HOW TO SOLVE THIS ASSIGNMENT
================================================================================

STEP 1: UNDERSTAND WHAT YOU NEED TO DO
   - Create samePerson as a REFERENCE to person (both point to same object)
   - Create clone1 and clone2 as INDEPENDENT COPIES of person
   - Modify person: age becomes 78, country becomes 'FR'
   - Check that clone1 and clone2 still have original values
   - Check that samePerson has the new values (because it's the same object)


STEP 2: CREATE THE COPIES
   
   For samePerson (reference copy):
   ├─ Simply assign: const samePerson = person
   └─ Both variables point to the SAME object
   
   For clone1 and clone2 (independent copies):
   ├─ Option 1: Use Object.assign()
   │  └─ const clone1 = Object.assign({}, person)
   │
   ├─ Option 2: Use the spread operator (...)
   │  └─ const clone2 = { ...person }
   │
   └─ Both create independent copies for simple objects


STEP 3: MODIFY THE ORIGINAL
   - Increase person.age by 1 (becomes 78)
   - Set person.country to 'FR'


STEP 4: VERIFY YOUR WORK
   - Clone1 should still be: { name: 'Rick', age: 77, country: 'US' }
   - Clone2 should still be: { name: 'Rick', age: 77, country: 'US' }
   - SamePerson should now be: { name: 'Rick', age: 78, country: 'FR' }


WHY THIS MATTERS IN REAL PROGRAMMING
================================================================================

Understanding mutability and copying is crucial because:

1. BUG PREVENTION: If you accidentally modify what you thought was a copy, 
   you might break code elsewhere that uses that object.

2. DATA INTEGRITY: Sometimes you need to preserve the original data. Sometimes 
   you need changes reflected everywhere. Knowing the difference is essential.

3. PERFORMANCE: Deep copying large objects takes more memory and time than 
   reference copying. You need to choose the right approach for your situation.


ALTERNATIVE METHODS (BONUS KNOWLEDGE)
================================================================================

You could also create deep copies with:

1. JSON Method (works for most objects):
   const clone = JSON.parse(JSON.stringify(person))
   
   How it works:
   - JSON.stringify() converts object to a string
   - JSON.parse() converts it back to a new object
   - This creates a completely independent copy

2. Recursion (more advanced):
   - Manually copying each property, checking if it's an object, 
     and recursively copying nested objects too
   - More complex but gives you full control


NOW, HERE'S YOUR COMPLETE SOLUTION
================================================================================

CODE IMPLEMENTATION:
---

// Original person object (provided)
const person = {
  name: 'Rick',
  age: 77,
  country: 'US',
}

// STEP 1: CREATE THREE COPIES
// ============================================

// clone1: Independent copy using spread operator
// This creates a NEW object with the same properties as person
// Changes to person will NOT affect clone1
const clone1 = { ...person }

// clone2: Independent copy using Object.assign()
// Object.assign() copies all properties from person into a new empty object
// Changes to person will NOT affect clone2
const clone2 = Object.assign({}, person)

// samePerson: Reference to the same object
// This does NOT create a copy - both variables point to the SAME object
// When person changes, samePerson will show those changes too
const samePerson = person


// STEP 2: MODIFY THE ORIGINAL PERSON OBJECT
// ============================================

// Increase age by 1
person.age = person.age + 1  // or simply: person.age += 1
// person.age is now 78

// Set country to 'FR'
person.country = 'FR'


// STEP 3: VERIFY THE RESULTS (Optional - for testing)
// ============================================

// You can use console.log to check your work:
console.log('Original person:', person)
// Expected output: { name: 'Rick', age: 78, country: 'FR' }

console.log('Clone 1:', clone1)
// Expected output: { name: 'Rick', age: 77, country: 'US' } - UNCHANGED!

console.log('Clone 2:', clone2)
// Expected output: { name: 'Rick', age: 77, country: 'US' } - UNCHANGED!

console.log('Same Person:', samePerson)
// Expected output: { name: 'Rick', age: 78, country: 'FR' } - CHANGED!


// EXPLANATION OF WHAT JUST HAPPENED:
// ============================================

/*
WHY clone1 AND clone2 DIDN'T CHANGE:
- When we used { ...person } and Object.assign({}, person), we created 
  NEW, INDEPENDENT objects
- These new objects had the SAME property VALUES as the original at that 
  moment, but they are separate objects in memory
- When we modified person, we only changed the ORIGINAL object, not the copies
- It's like the clones are "frozen in time" at the moment they were created

WHY samePerson DID CHANGE:
- We didn't create a copy - we just created another label (samePerson) 
  pointing to the SAME object as person
- Since person and samePerson point to the same object, when the object's 
  properties change, both variables see those changes
- It's like having two different names for the same person - when the person 
  changes, both names describe the same changes
*/


COMPARING THE METHODS
================================================================================

METHOD                  SYNTAX                      CREATES COPY?
─────────────────────  ─────────────────────────────  ─────────────
Spread Operator        const copy = { ...obj }       YES (shallow)
Object.assign()        const copy = Object.assign()   YES (shallow)
Direct Assignment      const copy = obj              NO (reference)
JSON Method            JSON.parse(JSON.stringify())   YES (deep)


SUMMARY
================================================================================

✓ Use { ...object } or Object.assign() when you want INDEPENDENT copies

✓ Use direct assignment ( const newVar = object ) when you want changes 
  to be REFLECTED everywhere

✓ Remember: Objects are mutable and passed by reference in JavaScript

✓ Small objects like person can use shallow copy methods

✓ For complex nested objects, use JSON method or deep copy functions


PRACTICE CHALLENGE
================================================================================

Try this:
1. Change samePerson.age directly (samePerson.age = 100)
2. Check what person.age is now - it should also be 100!
3. Check clone1.age - it should still be 77

This proves that samePerson and person are the same object, while clone1 is 
independent.


================================================================================
                        END OF IMPLEMENTATION GUIDE
================================================================================
